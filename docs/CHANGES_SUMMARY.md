# Summary of Changes: LangChain-Inspired Runnable Features

## Overview
Enhanced the Runnable library with comprehensive LangChain-inspired utilities for functional composition, error handling, caching, and more.

## Files Added

### 1. `src/Runnable/RunnableUtilities.cs` ? MAIN ADDITION
**Purpose**: Core utility classes and extension methods for advanced Runnable features

**Key Classes:**
- `RunnableLambda` - Quick creation of runnables from lambda functions
- `RunnablePassthrough` - Pass input through unchanged (with optional side effects)
- `RunnableEnhancedExtensions` - Extension methods for all Runnable types

**Extension Methods Added:**
- `Map<TNext>()` - Transform output without changing input signature
- `MapAsync<TNext>()` - Async output transformation
- `Tap()` - Execute side effects without modifying output
- `TapAsync()` - Async side effects
- `WithFallback()` - Provide fallback runnable on exceptions
- `WithFallbackValue()` - Provide fallback value on exceptions  
- `WithRetry()` - Retry failed operations with configurable attempts and delay
- `Filter()` - Conditional execution based on predicate
- `InvokeParallel()` - Run multiple runnables in parallel
- `BatchParallel()` - Process multiple inputs in parallel
- `WithCache()` - Cache results to avoid redundant computations
- `WithDelay()` - Add delay between invocations (rate limiting)
- `WithTimeout()` - Add timeout to async execution

### 2. `src/Runnable/RunnableMultiParam.cs`
**Purpose**: Concrete implementations for Runnable with 3-5 input parameters

**Classes Added:**
- `Runnable<T1, T2, T3, TOutput>`
- `Runnable<T1, T2, T3, T4, TOutput>`
- `Runnable<T1, T2, T3, T4, T5, TOutput>`

### 3. `docs/RunnableUtilities.md`
**Purpose**: Comprehensive documentation with examples for all new features

**Sections:**
- Pipe composition
- Lambda creation
- Passthrough
- Map/Transform
- Tap (side effects)
- WithFallback (error handling)
- WithRetry
- Filter
- Parallel execution
- Caching
- Delay & Timeout
- Real-world pipeline examples

### 4. `examples/RunnableUtilitiesExample/Program.cs`
**Purpose**: Executable examples demonstrating all new features

## Files Modified

### 1. `src/Runnable/Bases.cs`
**Changes**: Added BaseRunnable abstract classes for 3-5 parameters
- `BaseRunnable<T1, T2, T3, TOutput>`
- `BaseRunnable<T1, T2, T3, T4, TOutput>`
- `BaseRunnable<T1, T2, T3, T4, T5, TOutput>`

### 2. `src/Runnable/Interfaces.cs`
**Changes**: Added IRunnable interfaces for 3-5 parameters
- `IRunnable<T1, T2, T3, TOutput>`
- `IRunnable<T1, T2, T3, T4, TOutput>`
- `IRunnable<T1, T2, T3, T4, T5, TOutput>`

### 3. `src/Runnable/RunnableExtended.cs`
**Changes**: Added AsRunnable extension methods for 3-5 parameter Func delegates
- Organized by parameter count (0-5)
- Each with sync and async variants

### 4. `src/Runnable/Pipe.cs`
**Changes**: Added documentation noting that Pipe methods are auto-generated by source generator

## Feature Comparison with LangChain

| LangChain Feature | C# Runnable | Status |
|-------------------|-------------|--------|
| `invoke()` / `ainvoke()` | `Invoke()` / `InvokeAsync()` | ? Existing |
| `batch()` / `abatch()` | `Batch()` / `BatchAsync()` | ? Existing |
| `stream()` / `astream()` | `Stream()` | ? Existing |
| `pipe()` | `Pipe()` | ? Existing (source-generated) |
| `map()` | `Map()` / `MapAsync()` | ? NEW |
| `with_fallbacks()` | `WithFallback()` / `WithFallbackValue()` | ? NEW |
| `with_retry()` | `WithRetry()` | ? NEW |
| `RunnableLambda` | `RunnableLambda.Create()` | ? NEW |
| `RunnablePassthrough` | `RunnablePassthrough.Create()` | ? NEW |
| Tap/Side effects | `Tap()` / `TapAsync()` | ? NEW |
| Filtering | `Filter()` | ? NEW |
| Parallel execution | `BatchParallel()` / `InvokeParallel()` | ? NEW |
| Caching | `WithCache()` | ? NEW |
| Timeout | `WithTimeout()` | ? NEW |
| Rate limiting | `WithDelay()` | ? NEW |

## Usage Examples

### Basic Transformation
```csharp
var getLength = new Runnable<string, int>(s => s.Length);
var message = getLength.Map(len => $"Length: {len}");
Console.WriteLine(message.Invoke("Hello")); // "Length: 5"
```

### Error Handling
```csharp
var risky = new Runnable<int, string>(x => {
    if (x < 0) throw new Exception();
    return x.ToString();
});
var safe = risky.WithFallbackValue("error");
```

### Retry Logic
```csharp
var flaky = new Runnable<int, string>(x => MayFail(x));
var robust = flaky.WithRetry(maxAttempts: 3, delay: TimeSpan.FromMilliseconds(100));
```

### Complex Pipeline
```csharp
var pipeline = parseData
    .Filter(x => x >= 0)
    .Tap(x => Log(x))
    .Map(x => x * 2)
    .WithCache()
    .WithRetry(maxAttempts: 3)
    .WithFallbackValue(0)
    .WithTimeout(TimeSpan.FromSeconds(5));
```

## Benefits

1. **Composability**: Easily chain operations with fluent API
2. **Error Handling**: Built-in fallback and retry mechanisms
3. **Performance**: Caching and parallel execution support
4. **Debugging**: Tap for logging without modifying pipeline
5. **Type Safety**: Full C# generic type safety throughout
6. **Familiar**: Similar to LangChain for Python/JS developers
7. **Extensible**: Easy to add more extension methods

## Testing

Build Status: ? **Successful**

All new features compile successfully and are ready for use.

## Next Steps

Potential future enhancements:
- **RunnableParallel**: Explicit parallel composition with structured outputs
- **RunnableBranch**: Conditional branching based on input
- **RunnableRouter**: Route to different runnables based on criteria
- **Configuration System**: Runtime configuration override
- **Tracing/Observability**: Built-in tracing and monitoring support
- **Additional Base Classes**: Support for 6-16 parameters (interfaces already exist)

## Migration Guide

Existing code continues to work unchanged. New features are purely additive:

**Before:**
```csharp
var r1 = new Runnable<int, int>(x => x * 2);
var r2 = new Runnable<int, string>(x => x.ToString());
var result = r2.Invoke(r1.Invoke(5));
```

**After (with new utilities):**
```csharp
var r1 = RunnableLambda.Create<int, int>(x => x * 2);
var r2 = RunnableLambda.Create<int, string>(x => x.ToString());
var pipeline = r1.Pipe(r2); // or r1 | r2 if using pipe operator
var result = pipeline.Invoke(5);
```

Or with error handling:
```csharp
var pipeline = r1
    .Pipe(r2)
    .WithRetry(3)
    .WithFallbackValue("error");
```

## Conclusion

The Runnable library now provides a comprehensive, LangChain-inspired framework for building robust, composable data processing pipelines in C# with:
- ? Functional composition (Pipe, Map)
- ? Error handling (WithFallback, WithRetry)
- ? Performance optimization (WithCache, BatchParallel)
- ? Debugging support (Tap)
- ? Conditional execution (Filter)
- ? Resource management (WithTimeout, WithDelay)

All features maintain strong typing and integrate seamlessly with existing Runnable code.
