using Microsoft.CodeAnalysis;
using System.Text;

namespace Runnable.SourceGenerators
{
    [Generator]
    public class PipeMethodGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            context.RegisterPostInitializationOutput(ctx =>
            {
                var source = GenerateAllPipeMethods();
                ctx.AddSource("PipeExtensions.g.cs", source);
            });
        }

        private static string GenerateAllPipeMethods()
        {
            var sb = new StringBuilder();

            // File header
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Threading.Tasks;");
            sb.AppendLine();
            sb.AppendLine("namespace Runnable");
            sb.AppendLine("{");
            sb.AppendLine("    public static partial class PipeExtensions");
            sb.AppendLine("    {");

            // Generate Pipe methods for all combinations of parameter counts
            // firstParamCount: parameters of the first runnable (0-16)
            // secondParamCount: parameters of the second runnable (1-16, not 0 since second must consume first's output)
            // Constraint: firstParamCount + (secondParamCount - 1) <= 16 (result can't have more than 16 params)
            for (int firstParamCount = 0; firstParamCount <= 16; firstParamCount++)
            {
                for (int secondParamCount = 1; secondParamCount <= 16; secondParamCount++)
                {
                    // Calculate how many parameters the result will have
                    int resultParamCount = firstParamCount + (secondParamCount - 1);
                    
                    // Only generate if the result doesn't exceed 16 parameters
                    if (resultParamCount <= 16)
                    {
                        sb.AppendLine(GeneratePipeMethod(firstParamCount, secondParamCount));
                        sb.AppendLine();
                    }
                }
            }

            sb.AppendLine("    }");
            sb.AppendLine("}");

            return sb.ToString();
        }

        private static string GeneratePipeMethod(int firstParamCount, int secondParamCount)
        {
            // First runnable type params: T1, T2, ..., Tn, TOutput
            var firstTypeParams = GetFirstTypeParams(firstParamCount);
            
            // Second runnable additional type params (excluding TOutput): U1, U2, ..., Um
            // where m = secondParamCount - 1 for secondParamCount >= 1, or 0 for secondParamCount == 0
            var secondAdditionalCount = secondParamCount > 0 ? secondParamCount - 1 : 0;
            
            // All generic type params for the method: T1, ..., Tn, U1, ..., Um, TOutput, TNext
            var allTypeParams = GetAllTypeParams(firstParamCount, secondAdditionalCount);
            
            // Second interface type params: TOutput, U1, ..., Um for secondParamCount >= 1, or just empty for 0
            var secondInterfaceTypeParams = GetSecondInterfaceTypeParams(secondParamCount);
            
            // Result runnable type params: T1, ..., Tn, U1, ..., Um, TNext
            var resultTypeParams = GetResultTypeParams(firstParamCount, secondAdditionalCount);
            
            // Method parameters: T1 arg1, ..., Tn argn, U1 argn+1, ..., Um argn+m
            var methodParams = GetCombinedMethodParams(firstParamCount, secondAdditionalCount);
            
            // Arguments for first.Invoke: arg1, ..., argn
            var firstInvokeArgs = GetFirstInvokeArgs(firstParamCount);
            
            // Arguments for second.Invoke
            var secondInvokeArgs = GetSecondInvokeArgs(firstParamCount, secondParamCount, secondAdditionalCount);
            
            // Async second invoke args
            var asyncSecondInvokeArgs = GetAsyncSecondInvokeArgs(firstParamCount, secondParamCount, secondAdditionalCount);
            
            var asyncMethodParams = methodParams;

            return $@"        /// <summary>
        /// Pipeline connection method for {firstParamCount}-parameter Runnable to {secondParamCount}-parameter Runnable
        /// </summary>
        public static Runnable<{resultTypeParams}TNext> Pipe<{allTypeParams}TOutput, TNext>(
            this IRunnable<{firstTypeParams}TOutput> first,
            IRunnable<{secondInterfaceTypeParams}TNext> second)
        {{
            return new Runnable<{resultTypeParams}TNext>(
                ({methodParams}) => second.Invoke({secondInvokeArgs}),
                async ({asyncMethodParams}) => await second.InvokeAsync({asyncSecondInvokeArgs})
            );
        }}";
        }

        private static string GetFirstTypeParams(int firstParamCount)
        {
            if (firstParamCount == 0) return "";
            
            var sb = new StringBuilder();
            for (int i = 1; i <= firstParamCount; i++)
            {
                sb.Append($"T{i}, ");
            }
            return sb.ToString();
        }

        private static string GetAllTypeParams(int firstParamCount, int secondAdditionalCount)
        {
            var sb = new StringBuilder();
            
            // Add first's type params: T1, T2, ..., Tn
            for (int i = 1; i <= firstParamCount; i++)
            {
                sb.Append($"T{i}, ");
            }
            
            // Add second's additional type params: U1, U2, ..., Um
            for (int i = 1; i <= secondAdditionalCount; i++)
            {
                sb.Append($"U{i}, ");
            }
            
            return sb.ToString();
        }

        private static string GetSecondInterfaceTypeParams(int secondParamCount)
        {
            if (secondParamCount == 0) return "";
            
            var sb = new StringBuilder();
            // First param is always TOutput (from first runnable's output)
            sb.Append("TOutput");
            
            // Additional params: U1, U2, ..., Um
            for (int i = 1; i < secondParamCount; i++)
            {
                sb.Append($", U{i}");
            }
            
            sb.Append(", ");
            return sb.ToString();
        }

        private static string GetResultTypeParams(int firstParamCount, int secondAdditionalCount)
        {
            if (firstParamCount == 0 && secondAdditionalCount == 0) return "";
            
            var sb = new StringBuilder();
            
            // Add first's type params: T1, T2, ..., Tn
            for (int i = 1; i <= firstParamCount; i++)
            {
                sb.Append($"T{i}, ");
            }
            
            // Add second's additional type params: U1, U2, ..., Um
            for (int i = 1; i <= secondAdditionalCount; i++)
            {
                sb.Append($"U{i}, ");
            }
            
            return sb.ToString();
        }

        private static string GetCombinedMethodParams(int firstParamCount, int secondAdditionalCount)
        {
            if (firstParamCount == 0 && secondAdditionalCount == 0) return "";
            
            var sb = new StringBuilder();
            
            // Add first's parameters: T1 arg1, T2 arg2, ..., Tn argn
            for (int i = 1; i <= firstParamCount; i++)
            {
                if (sb.Length > 0) sb.Append(", ");
                sb.Append($"T{i} arg{i}");
            }
            
            // Add second's additional parameters: U1 argn+1, U2 argn+2, ..., Um argn+m
            for (int i = 1; i <= secondAdditionalCount; i++)
            {
                if (sb.Length > 0) sb.Append(", ");
                sb.Append($"U{i} arg{firstParamCount + i}");
            }
            
            return sb.ToString();
        }

        private static string GetFirstInvokeArgs(int firstParamCount)
        {
            if (firstParamCount == 0) return "";
            
            var sb = new StringBuilder();
            for (int i = 1; i <= firstParamCount; i++)
            {
                if (i > 1) sb.Append(", ");
                sb.Append($"arg{i}");
            }
            return sb.ToString();
        }

        private static string GetSecondInvokeArgs(int firstParamCount, int secondParamCount, int secondAdditionalCount)
        {
            var sb = new StringBuilder();
            
            if (secondParamCount > 0)
            {
                // First argument is the output of the first runnable
                sb.Append($"first.Invoke({GetFirstInvokeArgs(firstParamCount)})");
                
                // Add additional arguments: argn+1, argn+2, ..., argn+m
                for (int i = 1; i <= secondAdditionalCount; i++)
                {
                    sb.Append($", arg{firstParamCount + i}");
                }
            }
            
            return sb.ToString();
        }

        private static string GetAsyncSecondInvokeArgs(int firstParamCount, int secondParamCount, int secondAdditionalCount)
        {
            var sb = new StringBuilder();
            
            if (secondParamCount > 0)
            {
                // First argument is the awaited output of the first runnable
                sb.Append($"await first.InvokeAsync({GetFirstInvokeArgs(firstParamCount)})");
                
                // Add additional arguments: argn+1, argn+2, ..., argn+m
                for (int i = 1; i <= secondAdditionalCount; i++)
                {
                    sb.Append($", arg{firstParamCount + i}");
                }
            }
            
            return sb.ToString();
        }
    }
}
